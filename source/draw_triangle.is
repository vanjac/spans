	.section	.iwram, "ax", %progbits
	.align	2
	.code	32
	.arm
	.global	draw_triangle_solid
draw_triangle_solid:
	pointa:r0	@ pointer to vec2
	pointb:r1
	pointc:r2
	color:r3
	@ on stack: frame buffer pointer

	PUSH	{r3-r11,lr}		@ color at top of stack. 40 bytes pushed

	@ rotate points so 1 is on top (1-2 to the left of 1-3)
	LDR		ay:r7, [pointa, #4]
	LDR		by:r10, [pointb, #4]
	LDR		cy:r11, [pointc, #4]
	point1:r4
	point2:r5
	point3:r6
	CMP		ay, by
	BGE		a_ge_b
	CMP		ay, cy
	MOVLT	point1, pointa
	MOVLT	point2, pointb
	MOVLT	point3, pointc
	B		end_point_rotate
a_ge_b:
	CMP		by, cy
	MOVLT	point1, pointb
	MOVLT	point2, pointc
	MOVLT	point3, pointa
end_point_rotate:
	MOVGE	point1, pointc
	MOVGE	point2, pointa
	MOVGE	point3, pointb

	@ left/right (min/max)
	LDMIA	point1, {point1, y1_f:r8}
	x1_f:r4		@ was point1

	@ calc left slope = (x2 - x1) / (y2 - y1)

	LDMIA	point2, {x2_f:r7, y2_f:r9}
	SUB		num:r0, x2_f, x1_f		@ x2 - x1
	SUB		den:r1, y2_f, y1_f
	LSL		num, #8					@ 24.8 fixed point
	BL		divide
	MOV		dlx_f:r10, num

	@ calc right slope = (x3 - x1) / (y3 - y1)

	LDMIA	point3, {num, point3}
	y3_f:r6		@ was point3
	SUB		xdiff:r5, num, x2_f		@ x3 - x2
	SUB		num, x1_f				@ x3 - x1
	SUB		den, y3_f, y1_f
	LSL		num, #8					@ 24.8 fixed point
	BL		divide
	MOV		drx_f:r11, num

	@ compare y2 and y3 to find mid y and end y

	SUBS	den, y3_f, y2_f
	MOVLE	end_y:r2, y2_f
	MOVGT	end_y, y3_f
	MOVLE	y2_f, y3_f
	mid_y:r9		@ was y2_f
	ADDLE	x2_f, xdiff		@ = x3
	bottom_x_f:r7			@ was x2_f

	LDR		framebuffer:r3, [sp, #40]

	@ convert to vram pointers
	ASR		end_y, #8
	RSB		end_y, end_y, LSL #4
	LSL		end_y, #4
	ADD		end_y, framebuffer
	PUSH	{end_y}

	ASR		mid_y, #8				@ to int
	RSB		mid_y, mid_y, LSL #4	@ row *= 15
	LSL		mid_y, #5				@ multiplied by 480
	ADD		mid_y, framebuffer, LSL #1
	@ also use to store L/R flag
	ADDLE	mid_y, #1		@ from SUBS above

	row:r8		@ was y1_f
	ASR		row, #8					@ to int
	RSB		row, row, LSL #4		@ row *= 15
	LSL		row, #4
	ADD		row, framebuffer

	MOV		num, xdiff
	LSL		num, #8
	BL		divide
	MOV		bottom_slope_f:r6, num

	lx_f:r4		@ was x1_f
	MOV		rx_f:r5, lx_f

	@ r4: lx_f
	@ r5: rx_f
	@ r6: bottom_slope_f
	@ r7: bottom_x_f
	@ r8: row
	@ r9: mid_y * 2 + L/R flag
	@ r10:dlx_f
	@ r11:drx_f

	LDR		color:r3, [sp, #4]
	@ skip the loop?
	CMP		row, mid_y, LSR #1
	BGE		end_top_half
top_half_loop:
	MOV		xstart:r0, lx_f, ASR #8
	MOV		xend:r1, rx_f, ASR #8
	MOV		row_tmp:r2, row
	BL		draw_span_solid
	ADD		lx_f, dlx_f
	ADD		rx_f, drx_f
	ADD		row, #240
	CMP		row, mid_y, LSR #1
	BLT		top_half_loop
end_top_half:

	TST		mid_y, #1
	MOVNE	drx_f, bottom_slope_f
	MOVEQ	dlx_f, bottom_slope_f
	MOVNE	rx_f, bottom_x_f
	MOVEQ	lx_f, bottom_x_f

	POP		{end_y:r9}

	@ skip the loop?
	CMP		row, end_y
	BGE		end_bottom_half
bottom_half_loop:	@ copy of above
	MOV		xstart, lx_f, ASR #8
	MOV		xend, rx_f, ASR #8
	MOV		row_tmp:r2, row
	BL		draw_span_solid
	ADD		lx_f, dlx_f
	ADD		rx_f, drx_f
	ADD		row, #240
	CMP		row, end_y
	BLT		bottom_half_loop
end_bottom_half:
end_draw_triangle:

	ADD		sp, #4		@ pop color
	POP		{r4-r11,lr}
	BX		lr
