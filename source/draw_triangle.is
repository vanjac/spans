	.section	.iwram, "ax", %progbits
	.align	2
	.code	32
	.arm
	.global	draw_triangle_solid
draw_triangle_solid:
	point1:r0	@ pointer to vec2
	point2:r1
	point3:r2
	color:r3

	PUSH	{r4-r11,lr}		@ 36 bytes pushed

	@ TODO rotate points so 1 is on top (2 to the left of 3)

	@ clear room for scratch registers
	MOV		point1:r4, r0
	MOV		point2:r5, r1
	MOV		point3:r6, r2
	MOV		color:r7, r3

	@ left/right (min/max)
	LDMIA	point1, {point1, y1_f:r8}
	x1_f:r4		@ was point1

	@ calc left slope = (x2 - x1) / (y2 - y1)

	LDMIA	point2, {point2, y2_f:r9}
	xdiff:r5	@ was point2
	SUB		num:r0, xdiff, x1_f	@ x2 - x1
	SUB		den:r1, y2_f, y1_f
	LSL		num, #8				@ 24.8 fixed point
	BL		divide
	MOV		dlx_f:r10, num

	@ calc right slope = (x3 - x1) / (y3 - y1)

	LDMIA	point3, {num, point3}
	y3_f:r6		@ was point3
	SUB		xdiff, num			@ x2 - x3
	SUB		num, x1_f			@ x3 - x1
	SUB		den, y3_f, y1_f
	LSL		num, #8				@ 24.8 fixed point
	BL		divide
	MOV		drx_f:r11, num

	@ compare y2 and y3 to find mid y and end y

	SUB		den, y2_f, y3_f
	MOVGT	y2_f, y3_f
	mid_y:r9		@ was y2_f
	@ convert to vram pointer
	ASR		mid_y, #8				@ to int
	RSB		mid_y, mid_y, LSL #4	@ row *= 15
	LSL		mid_y, #5				@ multiplied by 480
	ADD		mid_y, #0x0C000000		@ shifted left 1
	@ also use to store L/R flag
	ADDGT	mid_y, #1

	MOV		num, xdiff
	LSL		num, #8
	BL		divide
	MOV		bottom_slope:r6, num

	row:r8		@ was y1_f
	ASR		row, #8					@ to int
	@ multiply by 240
	RSB		row, row, LSL #4		@ row *= 15
	LSL		row, #4
	ADD		row, #0x06000000

	lx_f:r4		@ was x1_f
	MOV		rx_f:r5, lx_f

	@ r4: lx_f
	@ r5: rx_f
	@ r6:
	@ r7: color
	@ r8: row
	@ r9: mid_y * 2 + L/R flag
	@ r10:dlx_f
	@ r11:drx_f

	MOV		span_color:r3, color
	@ TODO skip this loop
top_half_loop:
	MOV		xstart:r0, lx_f, ASR #8
	MOV		xend:r1, rx_f, ASR #8
	MOV		row_tmp:r2, row
	BL		draw_span_solid
	ADD		lx_f, dlx_f
	ADD		rx_f, drx_f
	ADD		row, #240
	CMP		row, mid_y, LSR #1
	BLT		top_half_loop

	@ TODO bottom half

	POP		{r4-r11,lr}
	BX		lr
